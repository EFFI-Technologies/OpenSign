name: SonarQube Scan

on:
  push:
    branches:
      - main  # Trigger the workflow only on the `main` branch
  pull_request:
    branches:
      - main  # Optionally, trigger the workflow on pull requests to `main`

jobs:
  sonarQubeScan:
    runs-on: ubuntu-latest  # Use Ubuntu for the job's runner

    steps:
      # Step 1: Checkout code
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Set up Docker to run the SonarQube scanner
      - name: Set up Docker for SonarQube scanner
        run: |
          docker pull sonarsource/sonar-scanner-cli:latest

      # Step 3: Set environment variables for SonarQube
      - name: Set environment variables
        run: |
          echo "SONAR_USER_HOME=${{ github.workspace }}/.sonar" >> $GITHUB_ENV
          echo "GIT_DEPTH=0" >> $GITHUB_ENV

      # Step 4: Cache SonarQube data to speed up subsequent runs
      - name: Cache SonarQube scanner data
        uses: actions/cache@v3
        with:
          path: ${{ github.workspace }}/.sonar/cache
          key: sonar-cache-${{ runner.os }}-${{ hashFiles('**/*.js') }}  # Adjust the file pattern as per your project
          restore-keys: |
            sonar-cache-${{ runner.os }}-

      # Step 5: Run the SonarQube scanner
      - name: Run SonarQube scanner
        run: |
          docker run --rm -e SONAR_USER_HOME=${{ github.workspace }}/.sonar \
            -v ${{ github.workspace }}:/usr/src -w /usr/src sonarsource/sonar-scanner-cli:latest \
            sonar-scanner -Dsonar.qualitygate.wait=true

      # Step 6: After script - Output message
      - name: After script - SonarQube Check Completed
        run: echo "SonarQube Check Completed!"

    # Allow failure, so the job doesnâ€™t block other steps in the workflow
    continue-on-error: true
